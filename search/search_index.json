{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NST Guide Documentation \u00b6 This repository holds general documentation about the National Scenic Trails Guide project. You can find more detailed documentation specifically about the data generation part of the project here . I'm currently building this project full-time in between jobs, but I want the project to move forward into the future as seamlessly as possible. As such, I want to document as much as possible about what I've learned on this project so that I can maintain the website and hopefully the mobile app as easily as possible. Good documentation also increases the likelihood that some developer out there might be interested in maintaining or contributing to the project.","title":"Home"},{"location":"#nst-guide-documentation","text":"This repository holds general documentation about the National Scenic Trails Guide project. You can find more detailed documentation specifically about the data generation part of the project here . I'm currently building this project full-time in between jobs, but I want the project to move forward into the future as seamlessly as possible. As such, I want to document as much as possible about what I've learned on this project so that I can maintain the website and hopefully the mobile app as easily as possible. Good documentation also increases the likelihood that some developer out there might be interested in maintaining or contributing to the project.","title":"NST Guide Documentation"},{"location":"map-data/","text":"Overview \u00b6 In order to serve a web map, you need to serve the underlying map data in some way. The most common way to do this is to pay a company like Google or Mapbox to license their data. Of course, this costs money. Furthermore, you're tied to the service provider. In the summer of 2018, Google raised prices by 14x almost overnight. If you'd built your platform on Google Maps, you're stuck. In any case, I wouldn't use Google Maps because their platform is much less friendly to developers. Mapbox's open source mapping apps are really easy to build upon, and are at the forefront of map tech. Mapbox is much friendlier, with a rather generous free tier . Going with Mapbox services is not a bad option, but I chose against it for a few reasons: Free project . NST Guide is designed to be a free product, so I wanted to minimize current and future costs. By hosting my own map data, I can have clarity about expected costs with low variance month-to-month. Infrequent updates okay . One of the benefits of hosted maps like Mapbox is that they update from OpenStreetMap or other providers often. OpenStreetMap data is updated by contributors every day, so if you're interested in an area with a high rate of changes, you might be more interested in paying for their maps. For a trail map, constant updates aren't as important. Don't need worldwide coverage . My app is focused on the U.S. West Coast to start, and potentially eventually the whole US. I never expect to need coverage outside the continental US, so generating map data is much less complex than for the entire globe. Learning experience . A main goal with this project is to learn how map technology works, and by generating my own tiles I've been able to get a deeper understanding of vector tiles. Low risk . If I ever run into problems with my self-hosted map data, I can change a line of code, add a Mapbox API key, and be using their basemaps within an hour.","title":"Overview"},{"location":"map-data/#overview","text":"In order to serve a web map, you need to serve the underlying map data in some way. The most common way to do this is to pay a company like Google or Mapbox to license their data. Of course, this costs money. Furthermore, you're tied to the service provider. In the summer of 2018, Google raised prices by 14x almost overnight. If you'd built your platform on Google Maps, you're stuck. In any case, I wouldn't use Google Maps because their platform is much less friendly to developers. Mapbox's open source mapping apps are really easy to build upon, and are at the forefront of map tech. Mapbox is much friendlier, with a rather generous free tier . Going with Mapbox services is not a bad option, but I chose against it for a few reasons: Free project . NST Guide is designed to be a free product, so I wanted to minimize current and future costs. By hosting my own map data, I can have clarity about expected costs with low variance month-to-month. Infrequent updates okay . One of the benefits of hosted maps like Mapbox is that they update from OpenStreetMap or other providers often. OpenStreetMap data is updated by contributors every day, so if you're interested in an area with a high rate of changes, you might be more interested in paying for their maps. For a trail map, constant updates aren't as important. Don't need worldwide coverage . My app is focused on the U.S. West Coast to start, and potentially eventually the whole US. I never expect to need coverage outside the continental US, so generating map data is much less complex than for the entire globe. Learning experience . A main goal with this project is to learn how map technology works, and by generating my own tiles I've been able to get a deeper understanding of vector tiles. Low risk . If I ever run into problems with my self-hosted map data, I can change a line of code, add a Mapbox API key, and be using their basemaps within an hour.","title":"Overview"},{"location":"map-data/generating/","text":"Generate Map Data \u00b6 A map of the globe contains so much information that it would be impossible to transmit all that information at high scale to a user at once. That's why map tiling schemes exist . With the standard pseudo-mercator tiling scheme , map zoom level 0 covers the globe; zoom level 1 is split into 4 tiles; zoom level 2 is split into 16 tiles, and so on. Zoom level n n has 4^n 4^n tiles that cover the globe. Raster vs Vector tiles \u00b6 Historically, map tiles were PNG images. This meant that for a web browser or mobile phone to display the map, all they had to do was display a collection of images. That approach is pretty simple for the client, which allows it to work on low-powered devices like those of the late 2000s. Modern map technology is going away from raster tiles and toward vector tiles. Instead of encoding RGB values of pixels, it encodes the actual geometries of the roads, streams, and points of interest to be displayed. This requires more effort on the client, but opens up a whole host of opportunities: Smooth zooming . Since the tiles are rendered on the client, you can have fractional zooms without any pixelation. Dynamic styling . Change how the map looks without needing to download new data. Smaller file sizes . In general, vector tiles have smaller file sizes than their raster equivalents. Extract data from the tile . Since the geometries are encoded in the data received by the client, the client could potentially do cool stuff like basic routing without needing any new data. Note that this isn't to say raster data is going away entirely! Some data is still well-suited to rasters, like aerial imagery or hillshading. OpenMapTiles \u00b6 The OpenMapTiles project defines a schema for how to encode data from OpenStreetMap into files conforming to the Mapbox Vector Tile specification , and offers tools for converting OpenStreetMap data into tiles of that schema. The schema defines a collection of tags for the geometries encoded in the vector tile, so that styles can be written for tiles with consistent layers. Note that in order to use a Mapbox GL style, it must be written specifically for the OpenMapTiles schema. A style written for the OpenMapTiles schema won't work with vector tile data coming from Mapbox, and a style written for Mapbox's vector tile schema won't work for OpenMapTiles. That means you can't just take a default Mapbox style, and use it for OpenMapTiles. Dynamic tile generation \u00b6 If you're trying to serve map tiles for a huge area, such as the entire globe, or with constant updates, the standard procedure would be to generate tiles dynamically. The process for doing dynamic tile generation is roughly: Construct an OpenMapTiles Postgres database with all the data of your desired region Create vector tiles on the fly, with a project such as martin . This approach, however, has higher costs because you need Postgres running on the backend. Since my project only serves the US and doesn't need constant updates, I use static tile generation instead. Static tile generation \u00b6 The general process for making tiles is: Install Docker Clone the OpenMapTiles repository Set the desired min/max zoom levels in .env Run for a region(s) of interest Combine the output .mbtiles files into a single .mbtiles file Serve it I use a modified fork of OpenMapTiles, which Encodes waterways and trails into the vector tiles at a lower zoom than the original OpenMapTiles project, so that they can be displayed when more zoomed out. Adds natural=spring and amenity=drinking_water to the POI layer. In code, the process is git clone https://github.com/nst-guide/openmaptiles cd openmaptiles sudo docker-compose pull ./quickstart.sh washington cp data/tiles.mbtiles ./washington.mbtiles ./quickstart.sh oregon cp data/tiles.mbtiles ./oregon.mbtiles tile-join joined.mbtiles washington.mbtiles oregon.mbtiles The argument to ./quickstart.sh is the region name. You can find valid region names in the OpenMapTiles documentation . The regions are downloaded from Geofabrik . So if you wanted you could run it on north-america , but I find it preferable to run smaller regions at a time. By making a separate mbtiles for each state, you can update each state individually. For example, if I generate individual .mbtiles files for every state, and then want to regenerate the map tiles for the Pacific Crest Trail, I only need to generate new data for California, Oregon, and Washington, and then combine the existing data from all other states with tile-join . So I'm never forced to regenerate data for more than one state at a time. Now that you've created a single .mbtiles file, you're to host it . Contours \u00b6 I originally generated contours vector tiles straight from USGS vector data ( https://github.com/nst-guide/contours ). These downloads have contour lines pregenerated in vector format, and so are quite easy to work with; just download, run ogr2ogr to convert to GeoJSON, and then run tippecanoe to convert to vector tiles. There are a couple drawbacks of using the USGS vector contour data: Inconsistent vertical spacing. In some areas, I found that the data included 10' contours, while others had a precision of only 80' . Since I desired a 40' contour, this meant that there were occasionally visual discontinuities in the map between tiles with source data of at least 40' precision and source data of less than 40' precision. Metric contours. Although I'm currently making maps of the United States, where imperial measurements are the standard, it's desirable to provide metric measurements as well. With Mapbox GL, it's quite easy to write a style expression that converts feet into meters, but the spacing of the contour lines will still be in feet. If neighboring imperial contour lines are 2000 feet and 2040 feet, displaying those same lines on a metric map would represent unintuitive values of 609.6 meters and 621.8 meters. In order to display metric contour lines, it is necessary to generate a separate set of contours with lines that represent 100 meters, 110 meters, etc. This must be generated from the original DEMs. Because of these issues, I try to generate contour data from the original DEMs, using code in nst-guide/terrain . Hillshading \u00b6 Historically, the way to make a hillshade is to generate raster images where each cell stores the level of grayscale to display. With Mapbox GL, you have a new option: Terrain RGB tiles . Instead of encoding the grayscale in the raster, it encodes the raw elevation value in 0.1m increments. This enables a whole host of cool things to do client-side, like retrieving elevation for a point, or generating the viewshed from a point. I currently exclusively use Terrain RGB tiles in my projects because it allows for the possibility of doing cool things client-side with elevation data. I generate Terrain tiles in nst-guide/terrain .","title":"Generating Map Data"},{"location":"map-data/generating/#generate-map-data","text":"A map of the globe contains so much information that it would be impossible to transmit all that information at high scale to a user at once. That's why map tiling schemes exist . With the standard pseudo-mercator tiling scheme , map zoom level 0 covers the globe; zoom level 1 is split into 4 tiles; zoom level 2 is split into 16 tiles, and so on. Zoom level n n has 4^n 4^n tiles that cover the globe.","title":"Generate Map Data"},{"location":"map-data/generating/#raster-vs-vector-tiles","text":"Historically, map tiles were PNG images. This meant that for a web browser or mobile phone to display the map, all they had to do was display a collection of images. That approach is pretty simple for the client, which allows it to work on low-powered devices like those of the late 2000s. Modern map technology is going away from raster tiles and toward vector tiles. Instead of encoding RGB values of pixels, it encodes the actual geometries of the roads, streams, and points of interest to be displayed. This requires more effort on the client, but opens up a whole host of opportunities: Smooth zooming . Since the tiles are rendered on the client, you can have fractional zooms without any pixelation. Dynamic styling . Change how the map looks without needing to download new data. Smaller file sizes . In general, vector tiles have smaller file sizes than their raster equivalents. Extract data from the tile . Since the geometries are encoded in the data received by the client, the client could potentially do cool stuff like basic routing without needing any new data. Note that this isn't to say raster data is going away entirely! Some data is still well-suited to rasters, like aerial imagery or hillshading.","title":"Raster vs Vector tiles"},{"location":"map-data/generating/#openmaptiles","text":"The OpenMapTiles project defines a schema for how to encode data from OpenStreetMap into files conforming to the Mapbox Vector Tile specification , and offers tools for converting OpenStreetMap data into tiles of that schema. The schema defines a collection of tags for the geometries encoded in the vector tile, so that styles can be written for tiles with consistent layers. Note that in order to use a Mapbox GL style, it must be written specifically for the OpenMapTiles schema. A style written for the OpenMapTiles schema won't work with vector tile data coming from Mapbox, and a style written for Mapbox's vector tile schema won't work for OpenMapTiles. That means you can't just take a default Mapbox style, and use it for OpenMapTiles.","title":"OpenMapTiles"},{"location":"map-data/generating/#dynamic-tile-generation","text":"If you're trying to serve map tiles for a huge area, such as the entire globe, or with constant updates, the standard procedure would be to generate tiles dynamically. The process for doing dynamic tile generation is roughly: Construct an OpenMapTiles Postgres database with all the data of your desired region Create vector tiles on the fly, with a project such as martin . This approach, however, has higher costs because you need Postgres running on the backend. Since my project only serves the US and doesn't need constant updates, I use static tile generation instead.","title":"Dynamic tile generation"},{"location":"map-data/generating/#static-tile-generation","text":"The general process for making tiles is: Install Docker Clone the OpenMapTiles repository Set the desired min/max zoom levels in .env Run for a region(s) of interest Combine the output .mbtiles files into a single .mbtiles file Serve it I use a modified fork of OpenMapTiles, which Encodes waterways and trails into the vector tiles at a lower zoom than the original OpenMapTiles project, so that they can be displayed when more zoomed out. Adds natural=spring and amenity=drinking_water to the POI layer. In code, the process is git clone https://github.com/nst-guide/openmaptiles cd openmaptiles sudo docker-compose pull ./quickstart.sh washington cp data/tiles.mbtiles ./washington.mbtiles ./quickstart.sh oregon cp data/tiles.mbtiles ./oregon.mbtiles tile-join joined.mbtiles washington.mbtiles oregon.mbtiles The argument to ./quickstart.sh is the region name. You can find valid region names in the OpenMapTiles documentation . The regions are downloaded from Geofabrik . So if you wanted you could run it on north-america , but I find it preferable to run smaller regions at a time. By making a separate mbtiles for each state, you can update each state individually. For example, if I generate individual .mbtiles files for every state, and then want to regenerate the map tiles for the Pacific Crest Trail, I only need to generate new data for California, Oregon, and Washington, and then combine the existing data from all other states with tile-join . So I'm never forced to regenerate data for more than one state at a time. Now that you've created a single .mbtiles file, you're to host it .","title":"Static tile generation"},{"location":"map-data/generating/#contours","text":"I originally generated contours vector tiles straight from USGS vector data ( https://github.com/nst-guide/contours ). These downloads have contour lines pregenerated in vector format, and so are quite easy to work with; just download, run ogr2ogr to convert to GeoJSON, and then run tippecanoe to convert to vector tiles. There are a couple drawbacks of using the USGS vector contour data: Inconsistent vertical spacing. In some areas, I found that the data included 10' contours, while others had a precision of only 80' . Since I desired a 40' contour, this meant that there were occasionally visual discontinuities in the map between tiles with source data of at least 40' precision and source data of less than 40' precision. Metric contours. Although I'm currently making maps of the United States, where imperial measurements are the standard, it's desirable to provide metric measurements as well. With Mapbox GL, it's quite easy to write a style expression that converts feet into meters, but the spacing of the contour lines will still be in feet. If neighboring imperial contour lines are 2000 feet and 2040 feet, displaying those same lines on a metric map would represent unintuitive values of 609.6 meters and 621.8 meters. In order to display metric contour lines, it is necessary to generate a separate set of contours with lines that represent 100 meters, 110 meters, etc. This must be generated from the original DEMs. Because of these issues, I try to generate contour data from the original DEMs, using code in nst-guide/terrain .","title":"Contours"},{"location":"map-data/generating/#hillshading","text":"Historically, the way to make a hillshade is to generate raster images where each cell stores the level of grayscale to display. With Mapbox GL, you have a new option: Terrain RGB tiles . Instead of encoding the grayscale in the raster, it encodes the raw elevation value in 0.1m increments. This enables a whole host of cool things to do client-side, like retrieving elevation for a point, or generating the viewshed from a point. I currently exclusively use Terrain RGB tiles in my projects because it allows for the possibility of doing cool things client-side with elevation data. I generate Terrain tiles in nst-guide/terrain .","title":"Hillshading"},{"location":"map-data/hosting/","text":"Map Hosting \u00b6 Now that you've generated map data, you need to host it to your users. S3 \u00b6 Pros: Serverless Cons: Lots of small individual files Normal server \u00b6 Expected cost per month: Static IP. As of April 1, 2020, $.004/hour or around $3/month. Cloudflare \u00b6 I use Cloudflare to save on bandwidth and improve download speeds. It's free! To point a URL to your server, add A records where the name is the subdomain you want to point, and the IP address is the static IP address of your server. You could also set up multiple subdomains that point to the same server. This allows for HTTP multiplexing with HTTP 1.1, essentially letting map tile requests be parallelized. It appears with HTTP 2.0 this might be unnecessary, but it's simple and Cloudflare says that currently 10% of my requests are HTTP 1.1 requests. Essentially, then in the tiles section of the Tile JSON you can list multiple domains, and all of them will return data in parallel. Server Firewall \u00b6 Since I'm sending all traffic through Cloudflare, I don't want any other HTTP or HTTPS access to the server. Allowing other access could 1) let attackers DDOS me by pointing directly to the IP address and 2) I could end up with higher egress bandwidth fees from Google since not everything is being cached by Cloudflare. To set up the firewall, add the current list of Cloudflare IP addresses to a new firewall. I found that Google got mad if I added IPv6 addresses, so I added just the ones below. Include tcp:80 and tcp:443 as protocols, and apply the firewall to the desired instances. 103.21.244.0/22 103.22.200.0/22 103.31.4.0/22 104.16.0.0/12 108.162.192.0/18 131.0.72.0/22 141.101.64.0/18 162.158.0.0/15 172.64.0.0/13 173.245.48.0/20 188.114.96.0/20 190.93.240.0/20 197.234.240.0/22 198.41.128.0/17 Now the server should only be accessible through your Cloudflare proxy! Static IP \u00b6 By default, the IP address you get when you start a Google Cloud server is ephemeral. It often stays the same for a while, but is allowed to change. In order for your DNS provider to make sure your URL always reaches your server, you need to make sure the IP address doesn't change. Here's an article on how to promote an ephemeral IP to address to a static IP address on Google Cloud. mbtileserver \u00b6 Now that we've set up the server, we need a program to serve the .mbtiles files. mbtileserver is a nice lightweight server for that, mapping HTTP requests to the desired tile within the SQLite file. Install \u00b6 First install Golang, then install the program go get github.com/consbio/mbtileserver Then the executable should reside at ~/go/bin/mbtileserver Using \u00b6 ./go/bin/mbtileserver \\ ` # Folder with mbtiles files` \\ -d mbtiles/ \\ ` # Port to run on` \\ -p 8000 \\ ` # Domain of website. Sets endpoint correctly in the Tile JSON` \\ --domain tiles.example.com \\ ` # Should allow server to restart if needed` \\ --enable-reload \\ ` # Verbose logging` \\ --verbose Each mbtiles file is given its own server path. If an mbtiles file is named openmaptiles.mbtiles , the Tile JSON endpoint would be localhost:8000/services/openmaptiles and the tiles would be at localhost:8000/services/openmaptiles/{z}/{x}/{y}.pbf I haven't figured out how to successfully change the domain name in the Tile JSON yet, see #88 . Caddy \u00b6 mbtileserver isn't meant to be directly exposed to the internet. For one, it's nice to add Cache-Control headers, which mbtileserver doesn't currently support. I use Caddy as a reverse proxy to call mbtileserver internally on port 8000. Install \u00b6 curl https://getcaddy.com | bash -s personal http.nobots,http.ratelimit If you want to include the nobots and ratelimit extensions, use: curl https://getcaddy.com | bash -s personal http.nobots,http.ratelimit The caddy executable should now be on the default PATH . Using \u00b6 Add a text file named Caddyfile to the current directory ( ~ is fine). I use something like: # Define each of the following websites, each on port 80 example.com:80, a_example.com:80, b_example.com:80 { proxy / localhost:8000 proxy /services/openmaptiles localhost:8000 { header_downstream Cache-Control \"public, max-age=20000, stale-while-revalidate=1000\" } log caddy_log.log { rotate_size 10 # Rotate a log when it reaches 10 MB rotate_age 14 # Keep rotated log files for 14 days rotate_keep 2 # Keep at most 2 rotated log files rotate_compress # Compress rotated log files in gzip format } errors caddy_errors.log { rotate_size 10 # Rotate a log when it reaches 10 MB rotate_age 14 # Keep rotated log files for 14 days rotate_keep 2 # Keep at most 2 rotated log files rotate_compress # Compress rotated log files in gzip format } } Higher ulimit \u00b6 Caddy complains that the default ulimit (number of open files at once) is too small. To fix this , in /etc/security/limits.conf I added: * soft nofile 8192 * hard nofile 64000","title":"Hosting Map Data"},{"location":"map-data/hosting/#map-hosting","text":"Now that you've generated map data, you need to host it to your users.","title":"Map Hosting"},{"location":"map-data/hosting/#s3","text":"Pros: Serverless Cons: Lots of small individual files","title":"S3"},{"location":"map-data/hosting/#normal-server","text":"Expected cost per month: Static IP. As of April 1, 2020, $.004/hour or around $3/month.","title":"Normal server"},{"location":"map-data/hosting/#cloudflare","text":"I use Cloudflare to save on bandwidth and improve download speeds. It's free! To point a URL to your server, add A records where the name is the subdomain you want to point, and the IP address is the static IP address of your server. You could also set up multiple subdomains that point to the same server. This allows for HTTP multiplexing with HTTP 1.1, essentially letting map tile requests be parallelized. It appears with HTTP 2.0 this might be unnecessary, but it's simple and Cloudflare says that currently 10% of my requests are HTTP 1.1 requests. Essentially, then in the tiles section of the Tile JSON you can list multiple domains, and all of them will return data in parallel.","title":"Cloudflare"},{"location":"map-data/hosting/#server-firewall","text":"Since I'm sending all traffic through Cloudflare, I don't want any other HTTP or HTTPS access to the server. Allowing other access could 1) let attackers DDOS me by pointing directly to the IP address and 2) I could end up with higher egress bandwidth fees from Google since not everything is being cached by Cloudflare. To set up the firewall, add the current list of Cloudflare IP addresses to a new firewall. I found that Google got mad if I added IPv6 addresses, so I added just the ones below. Include tcp:80 and tcp:443 as protocols, and apply the firewall to the desired instances. 103.21.244.0/22 103.22.200.0/22 103.31.4.0/22 104.16.0.0/12 108.162.192.0/18 131.0.72.0/22 141.101.64.0/18 162.158.0.0/15 172.64.0.0/13 173.245.48.0/20 188.114.96.0/20 190.93.240.0/20 197.234.240.0/22 198.41.128.0/17 Now the server should only be accessible through your Cloudflare proxy!","title":"Server Firewall"},{"location":"map-data/hosting/#static-ip","text":"By default, the IP address you get when you start a Google Cloud server is ephemeral. It often stays the same for a while, but is allowed to change. In order for your DNS provider to make sure your URL always reaches your server, you need to make sure the IP address doesn't change. Here's an article on how to promote an ephemeral IP to address to a static IP address on Google Cloud.","title":"Static IP"},{"location":"map-data/hosting/#mbtileserver","text":"Now that we've set up the server, we need a program to serve the .mbtiles files. mbtileserver is a nice lightweight server for that, mapping HTTP requests to the desired tile within the SQLite file.","title":"mbtileserver"},{"location":"map-data/hosting/#install","text":"First install Golang, then install the program go get github.com/consbio/mbtileserver Then the executable should reside at ~/go/bin/mbtileserver","title":"Install"},{"location":"map-data/hosting/#using","text":"./go/bin/mbtileserver \\ ` # Folder with mbtiles files` \\ -d mbtiles/ \\ ` # Port to run on` \\ -p 8000 \\ ` # Domain of website. Sets endpoint correctly in the Tile JSON` \\ --domain tiles.example.com \\ ` # Should allow server to restart if needed` \\ --enable-reload \\ ` # Verbose logging` \\ --verbose Each mbtiles file is given its own server path. If an mbtiles file is named openmaptiles.mbtiles , the Tile JSON endpoint would be localhost:8000/services/openmaptiles and the tiles would be at localhost:8000/services/openmaptiles/{z}/{x}/{y}.pbf I haven't figured out how to successfully change the domain name in the Tile JSON yet, see #88 .","title":"Using"},{"location":"map-data/hosting/#caddy","text":"mbtileserver isn't meant to be directly exposed to the internet. For one, it's nice to add Cache-Control headers, which mbtileserver doesn't currently support. I use Caddy as a reverse proxy to call mbtileserver internally on port 8000.","title":"Caddy"},{"location":"map-data/hosting/#install_1","text":"curl https://getcaddy.com | bash -s personal http.nobots,http.ratelimit If you want to include the nobots and ratelimit extensions, use: curl https://getcaddy.com | bash -s personal http.nobots,http.ratelimit The caddy executable should now be on the default PATH .","title":"Install"},{"location":"map-data/hosting/#using_1","text":"Add a text file named Caddyfile to the current directory ( ~ is fine). I use something like: # Define each of the following websites, each on port 80 example.com:80, a_example.com:80, b_example.com:80 { proxy / localhost:8000 proxy /services/openmaptiles localhost:8000 { header_downstream Cache-Control \"public, max-age=20000, stale-while-revalidate=1000\" } log caddy_log.log { rotate_size 10 # Rotate a log when it reaches 10 MB rotate_age 14 # Keep rotated log files for 14 days rotate_keep 2 # Keep at most 2 rotated log files rotate_compress # Compress rotated log files in gzip format } errors caddy_errors.log { rotate_size 10 # Rotate a log when it reaches 10 MB rotate_age 14 # Keep rotated log files for 14 days rotate_keep 2 # Keep at most 2 rotated log files rotate_compress # Compress rotated log files in gzip format } }","title":"Using"},{"location":"map-data/hosting/#higher-ulimit","text":"Caddy complains that the default ulimit (number of open files at once) is too small. To fix this , in /etc/security/limits.conf I added: * soft nofile 8192 * hard nofile 64000","title":"Higher ulimit"}]}